diff --git a/node_modules/@changesets/apply-release-plan/dist/changesets-apply-release-plan.cjs.js b/node_modules/@changesets/apply-release-plan/dist/changesets-apply-release-plan.cjs.js
index dea7ce5..5a7520d 100644
--- a/node_modules/@changesets/apply-release-plan/dist/changesets-apply-release-plan.cjs.js
+++ b/node_modules/@changesets/apply-release-plan/dist/changesets-apply-release-plan.cjs.js
@@ -408,15 +408,61 @@ async function getNewChangelogEntry(releasesWithPackage, changesets, config, cwd
   } else {
     throw new Error("Could not resolve changelog generation functions");
   }
+  let customGetChangelogEntry = typeof possibleChangelogFunc.getChangelogEntry === "function" ? possibleChangelogFunc.getChangelogEntry : undefined;
   let commits = await getCommitsThatAddChangesets(changesets.map(cs => cs.id), cwd);
   let moddedChangesets = changesets.map((cs, i) => _objectSpread2(_objectSpread2({}, cs), {}, {
     commit: commits[i]
   }));
   return Promise.all(releasesWithPackage.map(async release => {
-    let changelog = await getChangelogEntry(release, releasesWithPackage, moddedChangesets, getChangelogFuncs, changelogOpts, {
-      updateInternalDependencies: config.updateInternalDependencies,
-      onlyUpdatePeerDependentsWhenOutOfRange: config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH.onlyUpdatePeerDependentsWhenOutOfRange
-    });
+    let changelog;
+    if (customGetChangelogEntry) {
+      if (release.type === "none") {
+        changelog = null;
+      } else {
+        const changelogLines = {
+          major: [],
+          minor: [],
+          patch: []
+        };
+        moddedChangesets.forEach(cs => {
+          const rls = cs.releases.find(r => r.name === release.name);
+          if (rls && rls.type !== "none") {
+            changelogLines[rls.type].push(getChangelogFuncs.getReleaseLine(cs, rls.type, changelogOpts));
+          }
+        });
+        let dependentReleases = releasesWithPackage.filter(rel => {
+          var _release$packageJson$, _release$packageJson$2;
+          const dependencyVersionRange = (_release$packageJson$ = release.packageJson.dependencies) === null || _release$packageJson$ === void 0 ? void 0 : _release$packageJson$[rel.name];
+          const peerDependencyVersionRange = (_release$packageJson$2 = release.packageJson.peerDependencies) === null || _release$packageJson$2 === void 0 ? void 0 : _release$packageJson$2[rel.name];
+          const versionRange = dependencyVersionRange || peerDependencyVersionRange;
+          const usesWorkspaceRange = versionRange === null || versionRange === void 0 ? void 0 : versionRange.startsWith("workspace:");
+          return versionRange && (usesWorkspaceRange || validRange__default["default"](versionRange) !== null) && shouldUpdateDependencyBasedOnConfig({
+            type: rel.type,
+            version: rel.newVersion
+          }, {
+            depVersionRange: versionRange,
+            depType: dependencyVersionRange ? "dependencies" : "peerDependencies"
+          }, {
+            minReleaseType: config.updateInternalDependencies,
+            onlyUpdatePeerDependentsWhenOutOfRange: config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH.onlyUpdatePeerDependentsWhenOutOfRange
+          });
+        });
+        let relevantChangesetIds = new Set();
+        dependentReleases.forEach(rel => {
+          rel.changesets.forEach(cs => {
+            relevantChangesetIds.add(cs);
+          });
+        });
+        let relevantChangesets = moddedChangesets.filter(cs => relevantChangesetIds.has(cs.id));
+        changelogLines.patch.push(getChangelogFuncs.getDependencyReleaseLine(relevantChangesets, dependentReleases, changelogOpts));
+        changelog = await customGetChangelogEntry(release, changelogLines);
+      }
+    } else {
+      changelog = await getChangelogEntry(release, releasesWithPackage, moddedChangesets, getChangelogFuncs, changelogOpts, {
+        updateInternalDependencies: config.updateInternalDependencies,
+        onlyUpdatePeerDependentsWhenOutOfRange: config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH.onlyUpdatePeerDependentsWhenOutOfRange
+      });
+    }
     return _objectSpread2(_objectSpread2({}, release), {}, {
       changelog
     });
