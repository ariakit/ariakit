---
alwaysApply: true
---

# Ariakit Style Rules

These rules guide AI-assisted edits in this repository.

## Loops

- Always wrap `while` and `for` loop bodies in braces `{}`.
- Do not use single-line loop bodies without braces.

## Conditionals

- Default: wrap `if` bodies in braces `{}`.
- Allowed single-line exceptions only when the body is a single early-exit statement:
  - `if (cond) continue;`
  - `if (cond) break;`
  - `if (cond) return;`
  - `if (cond) return <primitive>;` where `<primitive>` is a simple literal (e.g., `true`, `false`, `0`, `42`, `""`, `[]`, `{}`, `null`, `undefined`).
- Prefer early returns to reduce nesting. For multiple early exits, write one `if` per line (do not combine with `||` for early exits):

  ```ts
  if (a) return;
  if (b) return;
  if (c) return;
  ```

  Avoid:

  ```ts
  if (a || b || c) return;
  ```

## Comments

- Multi-line comments should wrap at 80 characters.
- Explain the WHY and HOW, not the WHAT (the WHAT should be clear from good names).
- Place comments above the code they describe, not at the end of the line.
- Use JSDoc for functions, parameters, and types when top-level functions, APIs or non-obvious behavior.
- If logic feels complex, extract a well-named helper that explains the WHAT; add a short rationale comment if useful.
- If the comment is not JSDoc, it should start with `//`. If it's multi-line comment, each line should start with `//`.

## Functions

- Use the `function` keyword for module-level/top-level functions.
- Inside functions, declare nested helpers with `const` and arrow syntax:

  ```ts
  const helper = () => {
    // ...
  };
  ```

- Avoid deep nesting; prefer early returns and small helpers.

## TypeScript

- Type assertions and casts: Use safe, explicit operators that preserve type intent; disallow unsafe/unchecked casts that bypass the type system.
  - Allowed: `as const` to narrow literals; DOM-specific casts when preceded by runtime checks or guaranteed by well-typed APIs; `satisfies` to validate shapes without changing value types.
  - Disallowed: `as any`; `unknown as T` used to silence type errors.
  - Prefer proper typing with generics, discriminated unions, and user-defined type guards; when an assertion is truly necessary, keep it as narrow as possible and add a brief rationale above it.
- Prefer `interface` over `type` for object shapes. Use `type` only when interfaces cannot express the shape (e.g., unions, tuples, conditional or mapped types).
- Avoid abbreviated variable names (except conventional indices `i`, `j`, `k`). Use descriptive, intention-revealing names.
- When indexing arrays, guard against `undefined`. Do not use non-null assertions with indexed access.

  ```ts
  const item = array[i];
  if (!item) return; // or continue, break, etc.
  item.length;
  ```

  Or:

  ```ts
  const item = array[i];
  // For cases where falsy values are allowed, use `== null` instead of `!`
  if (item == null) return;
  item.length;
  ```

  Avoid:

  ```ts
  const item = array[i]!;
  item.length;
  ```

## Reuse and Abstraction

- Eliminate repetition by extracting shared logic into small, well-named functions.
- Choose names that convey intent so readers rarely need comments to understand WHAT a function does.

## Formatting and Readability

- Keep complex conditions readable; prefer early returns or well-named variables to long boolean chains.
- Maintain the existing indentation style and width of any file you edit.
