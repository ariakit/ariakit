---
import { getLangFromFilename, highlighter } from "#app/lib/shiki.ts";
import type { ThemedToken } from "shiki";
import type { CodeBlockProps } from "./code-block.types";

interface Props extends CodeBlockProps {}

const {
  code,
  filename,
  lang = filename ? getLangFromFilename(filename) : "text",
  maxLines,
  lineNumbers = false,
  highlightLines = [],
  highlightTokens = [],
} = Astro.props;

const { tokens } = highlighter.codeToTokens(code.trim(), {
  lang,
  themes: {
    light: "github-light",
    dark: "dark-plus",
  },
});

function isHighlighted(i: number) {
  return highlightLines.includes(i + 1);
}

function isCollapsed(lineIndex: number) {
  return maxLines !== undefined && lineIndex > maxLines;
}

// Helper function to find all text spans that should be highlighted
function findTextHighlights(content: string, line: ThemedToken[]) {
  const highlights: Array<{ start: number; end: number; text: string }> = [];
  const tokensSeen: Record<string, number> = {};

  highlightTokens.forEach((t) => {
    const [word, ...indexes] = Array.isArray(t) ? t : [t];

    let startIndex = 0;
    let foundIndex;
    let currentInstanceIndex = 0;

    while ((foundIndex = content.indexOf(word, startIndex)) !== -1) {
      // Check if this instance should be highlighted based on indexes
      const shouldHighlight =
        !indexes.length || indexes.includes(currentInstanceIndex);

      if (shouldHighlight) {
        highlights.push({
          start: foundIndex,
          end: foundIndex + word.length,
          text: word,
        });
      }

      startIndex = foundIndex + 1;
      currentInstanceIndex++;
    }
  });

  // Sort highlights by start position and merge overlapping ones
  highlights.sort((a, b) => a.start - b.start);

  const merged: typeof highlights = [];
  highlights.forEach((current) => {
    const last = merged[merged.length - 1];
    if (last && current.start <= last.end) {
      // Merge overlapping highlights
      last.end = Math.max(last.end, current.end);
    } else {
      merged.push(current);
    }
  });

  return merged;
}

// Helper function to create segments for text highlighting (returns data only)
function createHighlightSegments(
  line: ThemedToken[],
  textHighlights: ReturnType<typeof findTextHighlights>
) {
  type TokenFragment = {
    content: string;
    token: ThemedToken;
    isHighlighted: boolean;
    tokenIndex: number;
  };

  type Segment = {
    fragments: TokenFragment[];
    isHighlighted: boolean;
    spansMultipleTokens: boolean;
  };

  if (!line.some((token) => token.content)) {
    return { isEmpty: true, segments: [] as Segment[] };
  }

  // Create character-level mapping
  let currentPosition = 0;
  const allFragments: TokenFragment[] = [];

  // Process each token and split it if it crosses highlight boundaries
  line.forEach((token, tokenIndex) => {
    const tokenStart = currentPosition;
    const tokenEnd = currentPosition + token.content.length;

    // Find all highlight boundaries that intersect with this token
    const relevantHighlights = textHighlights.filter(
      (h) => h.start < tokenEnd && h.end > tokenStart
    );

    if (relevantHighlights.length === 0) {
      // Token is completely outside any highlights
      allFragments.push({
        content: token.content,
        token,
        isHighlighted: false,
        tokenIndex,
      });
    } else {
      // Token intersects with highlights - split it
      const splitPoints = new Set([tokenStart, tokenEnd]);

      // Add highlight boundaries as split points
      relevantHighlights.forEach((h) => {
        if (h.start > tokenStart && h.start < tokenEnd) {
          splitPoints.add(h.start);
        }
        if (h.end > tokenStart && h.end < tokenEnd) {
          splitPoints.add(h.end);
        }
      });

      const sortedSplitPoints = Array.from(splitPoints).sort((a, b) => a - b);

      // Create fragments between split points
      for (let i = 0; i < sortedSplitPoints.length - 1; i++) {
        const fragmentStart = sortedSplitPoints[i];
        const fragmentEnd = sortedSplitPoints[i + 1];

        // Check if this fragment is highlighted
        const isHighlighted = textHighlights.some(
          (h) => fragmentStart >= h.start && fragmentEnd <= h.end
        );

        // Extract the content for this fragment
        const relativeStart = fragmentStart - tokenStart;
        const relativeEnd = fragmentEnd - tokenStart;
        const fragmentContent = token.content.slice(relativeStart, relativeEnd);

        if (fragmentContent) {
          allFragments.push({
            content: fragmentContent,
            token,
            isHighlighted,
            tokenIndex,
          });
        }
      }
    }

    currentPosition += token.content.length;
  });

  // Group consecutive fragments with the same highlight status into segments
  const segments: Segment[] = [];
  let currentSegment: Segment | null = null;

  allFragments.forEach((fragment) => {
    if (
      !currentSegment ||
      currentSegment.isHighlighted !== fragment.isHighlighted
    ) {
      // Start new segment
      currentSegment = {
        fragments: [fragment],
        isHighlighted: fragment.isHighlighted,
        spansMultipleTokens: false,
      };
      segments.push(currentSegment);
    } else {
      // Add to current segment
      currentSegment.fragments.push(fragment);
    }
  });

  // Determine if each segment spans multiple tokens
  segments.forEach((segment) => {
    if (segment.isHighlighted && segment.fragments.length > 0) {
      const tokenIndexes = new Set(segment.fragments.map((f) => f.tokenIndex));
      segment.spansMultipleTokens = tokenIndexes.size > 1;
    }
  });

  return { isEmpty: false, segments };
}
---

<Fragment>
  <div
    class:list={[
      "grid whitespace-pre *:*:ps-4 **:data-highlight:ak-edge/25 **:data-highlight:shadow-[inset_calc(0.175rem+0.0625rem*var(--contrast,0))_0_var(--ak-border)]",
      lineNumbers && "sm:grid-cols-[max-content_1fr]",
    ]}
  >
    {
      lineNumbers && (
        <div
          aria-hidden
          class="max-sm:hidden -me-2 grid ak-layer-current sticky z-1 start-0 select-none pointer-events-none text-right ak-text-[#237893]/50 ak-dark:ak-text-[#858585]/50"
        >
          {tokens.map((_, i) => {
            const highlightLine = isHighlighted(i);
            return (
              <span
                data-highlight={highlightLine || undefined}
                class:list={[
                  "pe-4 h-(--line-height)",
                  { "ak-layer-pop": highlightLine },
                ]}
              >
                {i + 1}
              </span>
            );
          })}
        </div>
      )
    }
    <code>
      {
        tokens.map((line, i) => {
          const highlightLine = isHighlighted(i);

          // Get the full line content for text highlighting
          const lineContent = line.map((token) => token.content).join("");
          const textHighlights = findTextHighlights(lineContent, line);
          const { isEmpty, segments } = createHighlightSegments(
            line,
            textHighlights
          );

          return (
            <div
              data-highlight={highlightLine || undefined}
              class:list={[
                "pe-14 [content-visibility:auto] h-(--line-height)",
                highlightLine && "ak-layer-pop",
                isCollapsed(i) && "in-data-collapsed:hidden",
              ]}
            >
              {isEmpty
                ? "\n"
                : segments.map((segment) => {
                    const segmentElements = segment.fragments.map(
                      ({ content, token }) => {
                        // TODO: Fix this after we merge the site folder into root
                        const style = token.htmlStyle as any;
                        const dark = style?.["--shiki-dark"] || token.color;
                        const light = style?.color || token.color;
                        return (
                          <span
                            style={`--dark:${dark}; --light:${light}`}
                            class="ak-text-(--dark)/50 ak-light:ak-text-(--light)/65"
                          >
                            {content || ""}
                          </span>
                        );
                      }
                    );

                    // Apply highlighting if needed
                    if (segment.isHighlighted) {
                      const highlightClass = "ring rounded px-[0.25em] py-0.5";

                      if (segment.spansMultipleTokens) {
                        // Multi-token highlight
                        return (
                          <span
                            class:list={[
                              "ak-layer-pop ak-edge/25",
                              highlightClass,
                            ]}
                          >
                            {segmentElements}
                          </span>
                        );
                      }
                      // Single token highlight - use token colors for background
                      const firstFragment = segment.fragments[0];
                      const style = firstFragment.token.htmlStyle as any;
                      const dark =
                        style?.["--shiki-dark"] || firstFragment.token.color;
                      const light = style?.color || firstFragment.token.color;

                      return (
                        <span
                          style={`--dark:${dark}; --light:${light}`}
                          class:list={[
                            "ak-text-(--dark)/50 ak-light:ak-text-(--light)/65 ak-layer-mix-(--ak-text)/10 ak-edge-(--ak-text)/20",
                            highlightClass,
                          ]}
                        >
                          {segmentElements}
                        </span>
                      );
                    }

                    return segmentElements;
                  })}
            </div>
          );
        })
      }</code
    >
  </div>
</Fragment>
