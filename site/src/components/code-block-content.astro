---
import { getLangFromFilename, highlighter } from "#app/lib/shiki.ts";
import type { CodeBlockProps } from "./code-block.types";

interface Props extends CodeBlockProps {}

const {
  code,
  filename,
  lang = filename ? getLangFromFilename(filename) : "text",
  maxLines,
  lineNumbers = false,
  highlightLines = [],
  highlightTokens = [],
} = Astro.props;

const { tokens } = highlighter.codeToTokens(code.trim(), {
  lang,
  themes: {
    light: "github-light",
    dark: "dark-plus",
  },
});

const tokensSeen: Record<string, number> = {};

function isHighlighted(i: number) {
  return highlightLines.includes(i + 1);
}

function isCollapsed(lineIndex: number) {
  return maxLines !== undefined && lineIndex > maxLines;
}

// Original splitContent function for single token highlighting
function splitContent(content: string) {
  const tokens = content.split(/([^:\(\)\s"']+)/);
  return tokens.flatMap((token) => {
    const highlightToken = highlightTokens.some((t) => {
      const [word, ...indexes] = Array.isArray(t) ? t : [t];
      if (token !== word) return false;
      if (!indexes.length) return token === word;
      if (!(word in tokensSeen)) {
        tokensSeen[word] = 0;
      }
      const index = tokensSeen[word]++;
      return indexes.includes(index);
    });
    return { content: token, highlightToken };
  });
}

// Helper function to find text spans that should be highlighted (multi-token/substring)
function findTextHighlights(lineContent: string, lineTokens: any[]) {
  const highlights: Array<{ start: number; end: number; text: string }> = [];

  highlightTokens.forEach((t) => {
    const [word, ...indexes] = Array.isArray(t) ? t : [t];

    // Skip if this is a single token (handled by splitContent)
    if (lineTokens.some((token) => token.content === word)) return;

    let startIndex = 0;
    let foundIndex;
    let currentInstanceIndex = 0;

    while ((foundIndex = lineContent.indexOf(word, startIndex)) !== -1) {
      // Check if this instance should be highlighted based on indexes
      const shouldHighlight =
        !indexes.length || indexes.includes(currentInstanceIndex);

      if (shouldHighlight) {
        highlights.push({
          start: foundIndex,
          end: foundIndex + word.length,
          text: word,
        });
      }

      startIndex = foundIndex + 1;
      currentInstanceIndex++;
    }
  });

  // Sort highlights by start position and merge overlapping ones
  highlights.sort((a, b) => a.start - b.start);

  const merged: typeof highlights = [];
  highlights.forEach((current) => {
    const last = merged[merged.length - 1];
    if (last && current.start <= last.end) {
      // Merge overlapping highlights
      last.end = Math.max(last.end, current.end);
    } else {
      merged.push(current);
    }
  });

  return merged;
}

// Helper function to create segments for text highlighting (returns data only)
function createHighlightSegments(
  line: any[],
  textHighlights: ReturnType<typeof findTextHighlights>
) {
  type TokenFragment = {
    content: string;
    token: any;
    isHighlighted: boolean;
  };

  type Segment = {
    fragments: TokenFragment[];
    isHighlighted: boolean;
  };

  if (!line.some((token) => token.content)) {
    return { isEmpty: true, segments: [] as Segment[] };
  }

  // Create character-level mapping
  let currentPosition = 0;
  const allFragments: TokenFragment[] = [];

  // Process each token and split it if it crosses highlight boundaries
  line.forEach((token) => {
    const tokenStart = currentPosition;
    const tokenEnd = currentPosition + token.content.length;

    // Find all highlight boundaries that intersect with this token
    const relevantHighlights = textHighlights.filter(
      (h) => h.start < tokenEnd && h.end > tokenStart
    );

    if (relevantHighlights.length === 0) {
      // Token is completely outside any highlights
      allFragments.push({
        content: token.content,
        token,
        isHighlighted: false,
      });
    } else {
      // Token intersects with highlights - split it
      const splitPoints = new Set([tokenStart, tokenEnd]);

      // Add highlight boundaries as split points
      relevantHighlights.forEach((h) => {
        if (h.start > tokenStart && h.start < tokenEnd) {
          splitPoints.add(h.start);
        }
        if (h.end > tokenStart && h.end < tokenEnd) {
          splitPoints.add(h.end);
        }
      });

      const sortedSplitPoints = Array.from(splitPoints).sort((a, b) => a - b);

      // Create fragments between split points
      for (let i = 0; i < sortedSplitPoints.length - 1; i++) {
        const fragmentStart = sortedSplitPoints[i];
        const fragmentEnd = sortedSplitPoints[i + 1];

        // Check if this fragment is highlighted
        const isHighlighted = textHighlights.some(
          (h) => fragmentStart >= h.start && fragmentEnd <= h.end
        );

        // Extract the content for this fragment
        const relativeStart = fragmentStart - tokenStart;
        const relativeEnd = fragmentEnd - tokenStart;
        const fragmentContent = token.content.slice(relativeStart, relativeEnd);

        if (fragmentContent) {
          allFragments.push({
            content: fragmentContent,
            token,
            isHighlighted,
          });
        }
      }
    }

    currentPosition += token.content.length;
  });

  // Group consecutive fragments with the same highlight status into segments
  const segments: Segment[] = [];
  let currentSegment: Segment | null = null;

  allFragments.forEach((fragment) => {
    if (
      !currentSegment ||
      currentSegment.isHighlighted !== fragment.isHighlighted
    ) {
      // Start new segment
      currentSegment = {
        fragments: [fragment],
        isHighlighted: fragment.isHighlighted,
      };
      segments.push(currentSegment);
    } else {
      // Add to current segment
      currentSegment.fragments.push(fragment);
    }
  });

  return { isEmpty: false, segments };
}
---

<Fragment>
  <div
    class:list={[
      "grid whitespace-pre *:*:ps-4 **:data-highlight:ak-edge/25 **:data-highlight:shadow-[inset_calc(0.175rem+0.0625rem*var(--contrast,0))_0_var(--ak-border)]",
      lineNumbers && "sm:grid-cols-[max-content_1fr]",
    ]}
  >
    {
      lineNumbers && (
        <div
          aria-hidden
          class="max-sm:hidden -me-2 grid ak-layer-current sticky z-1 start-0 select-none pointer-events-none text-right ak-text-[#237893]/50 ak-dark:ak-text-[#858585]/50"
        >
          {tokens.map((_, i) => {
            const highlightLine = isHighlighted(i);
            return (
              <span
                data-highlight={highlightLine || undefined}
                class:list={[
                  "pe-4 h-(--line-height)",
                  { "ak-layer-pop": highlightLine },
                ]}
              >
                {i + 1}
              </span>
            );
          })}
        </div>
      )
    }
    <code>
      {
        tokens.map((line, i) => {
          const highlightLine = isHighlighted(i);

          // Get the full line content for text highlighting
          const lineContent = line.map((token) => token.content).join("");
          const textHighlights = findTextHighlights(lineContent, line);
          const { isEmpty, segments } = createHighlightSegments(
            line,
            textHighlights
          );

          return (
            <div
              data-highlight={highlightLine || undefined}
              class:list={[
                "pe-14 [content-visibility:auto] h-(--line-height)",
                highlightLine && "ak-layer-pop",
                isCollapsed(i) && "in-data-collapsed:hidden",
              ]}
            >
              {isEmpty
                ? "\n"
                : segments.map((segment) => {
                    const highlightClass = "ring rounded px-[0.5ch] py-0.5";
                    const segmentElements = segment.fragments
                      .map(({ content, token }) => {
                        // Apply splitContent logic to each fragment
                        const splitTokens = splitContent(content);
                        return splitTokens.map(
                          ({ content: splitContent, highlightToken }) => {
                            // TODO: Fix this after we merge the site folder into root
                            const style = token.htmlStyle as any;
                            const dark = style?.["--shiki-dark"] || token.color;
                            const light = style?.color || token.color;
                            const baseEl = (
                              <span
                                style={`--dark:${dark}; --light:${light}`}
                                class="ak-text-(--dark)/50 ak-light:ak-text-(--light)/65"
                              >
                                {splitContent || ""}
                              </span>
                            );
                            // Apply individual token highlighting if needed (single token)
                            if (highlightToken) {
                              return (
                                <span
                                  style={`--dark:${dark}; --light:${light}`}
                                  class:list={[
                                    "ak-text-(--dark)/50 ak-light:ak-text-(--light)/65 ak-layer-mix-(--ak-text)/10 ak-edge-(--ak-text)/20",
                                    highlightClass,
                                  ]}
                                >
                                  {baseEl}
                                </span>
                              );
                            }
                            return baseEl;
                          }
                        );
                      })
                      .flat();
                    // Wrap in text highlight span if needed (multi-token/substring)
                    if (segment.isHighlighted) {
                      return (
                        <span
                          class:list={[
                            "ak-layer-pop ak-edge/25",
                            highlightClass,
                          ]}
                        >
                          {segmentElements}
                        </span>
                      );
                    } else {
                      return segmentElements;
                    }
                  })}
            </div>
          );
        })
      }</code
    >
  </div>
</Fragment>
