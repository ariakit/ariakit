---
/**
 * @license
 * Copyright 2025-present Ariakit FZ-LLC. All Rights Reserved.
 *
 * This software is proprietary. See the license.md file in the root of this
 * package for licensing terms.
 *
 * SPDX-License-Identifier: UNLICENSED
 */
import { ReferenceHovercardAnchor } from "#app/components/reference-hovercard.react.tsx";
import {
  isLegacyReferenceURLLike,
  legacyToReferencePath,
  parseReferenceURL,
} from "#app/lib/url.ts";
import type { ComponentProps } from "astro/types";
import type { CollectionEntry } from "astro:content";
import { getCollection } from "astro:content";
import { InlineLink } from "./inline-link.react.tsx";

interface Props extends Omit<ComponentProps<typeof InlineLink>, "ref"> {
  reference?: "auto" | false;
}

const {
  reference = !!import.meta.env.DISABLE_REFERENCE_LINKS ? false : "auto",
  newWindow,
  iconLeft,
  iconRight,
  ...props
} = Astro.props;

function isExternalLink(url?: string): boolean {
  if (!url) return false;
  const internalHosts = new Set([
    "ariakit.org",
    "www.ariakit.org",
    "next.ariakit.org",
    "ariakit.com",
    "www.ariakit.com",
    "next.ariakit.com",
    "localhost:4321",
  ]);
  // Check if it's a full URL (starts with http:// or https://)
  if (url.startsWith("http://") || url.startsWith("https://")) {
    try {
      const linkUrl = new URL(url);
      return !internalHosts.has(linkUrl.hostname);
    } catch {
      // If URL parsing fails, treat as external for safety
      return true;
    }
  }
  // Check for protocol-relative URLs (//example.com)
  if (url.startsWith("//")) {
    return true;
  }
  // Check for mailto:, tel:, etc.
  if (url.includes(":") && !url.startsWith("/") && !url.startsWith("#")) {
    return true;
  }
  return false;
}

async function getReferenceText() {
  if (!reference) return null;
  // Extract inner HTML if the slot is a single <code>...</code> element
  const rawSlotHtml = (await Astro.slots.render("default"))?.trim() ?? "";
  const codeMatch = rawSlotHtml.match(
    /^<code(?:\s[^>]*)?>([\s\S]*?)<\/code>\s*$/i
  );
  const slotLabelHtml = codeMatch?.[1] ?? rawSlotHtml;
  // Remove any surrounding whitespace in the textual label
  return slotLabelHtml
    .replace(/\n/g, " ")
    .replace(/<[^>]*>/g, "")
    .trim();
}

async function getReferenceKind(
  convertedHref: string | undefined,
  references: CollectionEntry<"references">[]
) {
  if (!reference) return null;
  const parsed = convertedHref
    ? parseReferenceURL(convertedHref, references)
    : null;
  return parsed?.item?.kind ? "prop" : parsed?.reference.data.kind;
}

const referenceText = await getReferenceText();
const references = await getCollection("references");
const href =
  props.href && isLegacyReferenceURLLike(props.href)
    ? legacyToReferencePath(props.href, references)
    : props.href;
const referenceKind = await getReferenceKind(href, references);
const shouldOpenInNewWindow = newWindow ?? isExternalLink(href);
---

{
  referenceText && referenceKind ? (
    <ReferenceHovercardAnchor
      client:idle
      kind={referenceKind}
      inHovercard={!!Astro.locals.reference}
      {...props}
      href={href}
    >
      {referenceText}
    </ReferenceHovercardAnchor>
  ) : (
    <InlineLink
      newWindow={shouldOpenInNewWindow}
      iconLeft={iconLeft}
      iconRight={iconRight}
      {...props}
      href={href}
    >
      <slot />
    </InlineLink>
  )
}
