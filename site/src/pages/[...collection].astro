---
/**
 * @license
 * Copyright 2025-present Ariakit FZ-LLC. All Rights Reserved.
 *
 * This software is proprietary. See the license.md file in the root of this
 * package for licensing terms.
 *
 * SPDX-License-Identifier: UNLICENSED
 */
import { BoxPatternsMiddle } from "#app/components/box-patterns.react.tsx";
import ChipLinkList from "#app/components/chip-link-list.astro";
import ChipLink from "#app/components/chip-link.astro";
import HorizontalScroll from "#app/components/horizontal-scroll.astro";
import Meta from "#app/components/meta.astro";
import PageCardComponent from "#app/components/page-card-component.astro";
import PageCardExample from "#app/components/page-card-example.astro";
import SidebarMenu from "#app/components/sidebar-menu.astro";
import TimelineAnchor from "#app/components/timeline-anchor.astro";
import { Icon } from "#app/icons/icon.react.tsx";
import { uniq } from "#app/lib/array.ts";
import {
  filterGuidesByGroup,
  filterPreviews,
  getGuideDetail,
} from "#app/lib/content.ts";
import { getFramework } from "#app/lib/frameworks.ts";
import { capitalize } from "#app/lib/string.ts";
import { mapTags } from "#app/lib/tags.ts";
import Layout from "#app/pages/_layout.astro";
import type { GetStaticPaths } from "astro";
import { getCollection } from "astro:content";
import pluralize from "pluralize";

export const getStaticPaths = (async () => {
  const types = ["components", "examples"] as const;
  const entries = (
    await Promise.all(types.map((t) => getCollection(t)))
  ).flat();
  const previews = await getCollection("previews");
  const frameworks = uniq(entries.flatMap((entry) => entry.data.frameworks));

  return frameworks.flatMap((framework) => {
    const frameworkEntries = entries
      .filter((entry) => entry.data.frameworks.includes(framework))
      .sort((a, b) => a.data.title.localeCompare(b.data.title));

    return types.flatMap((type) => {
      const typeEntries = frameworkEntries.filter(
        (entry) => entry.collection === type
      );
      const typePreviews = previews.filter(filterPreviews({ framework, type }));
      const frameworkLength = typePreviews.length;

      const tags = mapTags(
        typeEntries.flatMap((entry) => entry.data.tags),
        [framework]
      );
      // Calculate the number of entries for each tag.
      const tagsWithLength = tags.map((tag) => {
        const tagEntries = typeEntries.filter(
          (entry) => !!entry.data.tags.find((t) => t === tag?.id)
        );
        const tagPreviews = typePreviews.filter(
          filterPreviews({ entries: tagEntries })
        );
        const tagLength = tagPreviews.length;
        return { ...tag, length: tagLength };
      });
      // Create a page for each tag, plus a page for all entries (null tag).
      return [null, ...tags].map((tag) => {
        const tagEntries = !tag
          ? typeEntries
          : typeEntries.filter(
              (entry) => !!entry.data.tags.find((t) => t === tag?.id)
            );
        const path = tag ? `${type}/${tag.id}` : type;
        return {
          params: { collection: `${framework}/${path}` },
          props: {
            framework,
            type,
            entries: tagEntries,
            tag,
            tags: tagsWithLength,
            frameworkLength,
          },
        };
      });
    });
  });
}) satisfies GetStaticPaths;

const { framework, type, frameworkLength, tags, tag, entries } = Astro.props;

Astro.locals.framework = framework;

function getTagPath(tag: (typeof tags)[number] | null) {
  const tagPath = tag?.id ? `/${tag.id}` : "";
  return `/${framework}/${type}${tagPath}/#tags`;
}

const frameworkData = getFramework(framework);

const typeTitle = capitalize(type);
const title = `${frameworkData.label} ${tag?.label || ""} ${typeTitle}`;

const groupPath = `/${framework}/${type}`;
const guides = (
  await getCollection("guides", filterGuidesByGroup(groupPath))
).map(getGuideDetail);
const hasGuides = guides.length > 0;
---

<Layout {title}>
  <Meta slot="meta" type={type} title={title} framework={framework} />
  <div
    class="ak-container-size-default py-24 ak-container flex flex-col items-center gap-8"
  >
    <div class="flex flex-col items-center gap-4">
      {
        !!guides[0] && (
          <TimelineAnchor
            as="a"
            name="sidebar-menu"
            href={guides[0].path}
            class="ak-button rounded-full ak-badge-primary text-sm"
          >
            <span>Get Started with {typeTitle}</span>
            <Icon name="arrowRight" className="flex-none" />
          </TimelineAnchor>
        )
      }
      <h1
        class="text-2xl @3xl:text-4xl font-semibold relative text-center flex items-center gap-2"
      >
        {
          type === "examples" && (
            <span class="ak-text-primary/0">{frameworkLength}</span>
          )
        }
        {
          type === "components" && (
            <Icon name={frameworkData.icon} className="flex-none" />
          )
        }
        {frameworkData.label}
        {pluralize(typeTitle, frameworkLength)}
        <BoxPatternsMiddle />
      </h1>
    </div>
    <div class="flex flex-col gap-4 items-center">
      <button
        class="ak-input flex items-center gap-2 ak-frame-field/1 text-start"
      >
        <div class="flex items-center gap-2 ak-frame-field/2 flex-grow min-w-0">
          <Icon name="search" className="flex-none" />
          <div class="ak-input-placeholder truncate">
            Search {frameworkData.label}
            {pluralize(typeTitle, frameworkLength)}
          </div>
        </div>
        <div class="flex-1 w-10"></div>
        <kbd class="ak-text/0 ak-layer-pop-1.5 ak-frame-field/2">
          {type === "components" ? "," : "/"}
        </kbd>
      </button>
    </div>
  </div>
  <div
    class="sticky top-(--header-height) ak-layer-current w-full h-px z-2 -translate-y-px"
  >
  </div>
  <div
    id="tags"
    class:list={[
      "ak-layer-current ring scroll-mt-[calc(var(--header-height)-1px)] content-start",
      "[--p:var(--ak-container-p)]",
      "[--sidebar-menu-width:max(14rem,calc(100%-min(100%,var(--container-default)+var(--ak-container-p)*2))/2)]",
      "grid-cols-[var(--sidebar-menu-width)_min(calc(100%-var(--sidebar-menu-width)),var(--container-default)+var(--ak-container-p)*2)]",
      "@max-overlap:grid-cols-[var(--sidebar-menu-width)_1fr]",
      hasGuides && "@5xl:grid",
    ]}
  >
    {
      hasGuides && (
        <SidebarMenu
          revealAnchorName="sidebar-menu"
          id="tags-menu"
          items={[
            {
              label: capitalize(type),
              href: `${groupPath}/`,
              currentPage: !!tag,
            },
            { label: "Guides" },
            ...guides.map((guide) => ({
              label: guide.data.title,
              href: guide.path,
            })),
          ]}
        />
      )
    }
    <div
      class:list={[
        "flex flex-col ak-layer-current z-1 min-h-[100dvh]",
        hasGuides
          ? "@5xl:border-e"
          : "@default:border-x ak-container-size-[calc(var(--container-default)+var(--p)*2)]/0 ak-container",
      ]}
    >
      <HorizontalScroll
        id="tags-scroll"
        class="sticky top-(--header-height) z-2 ak-layer-current [box-shadow:0_1px_0_0_var(--ak-layer-border)]"
      >
        <ChipLinkList>
          {
            [null, ...tags].map((t) => {
              const isCurrent = t?.id === tag?.id;
              const length = t?.length ?? frameworkLength;
              return (
                <li>
                  <ChipLink href={getTagPath(t)} current={isCurrent}>
                    {t?.label ?? "All"}
                    <span slot="badge">
                      {length}
                      <span class="sr-only">{pluralize(type, length)}</span>
                    </span>
                  </ChipLink>
                </li>
              );
            })
          }
        </ChipLinkList>
      </HorizontalScroll>
      <div
        class="grid grid-cols-[repeat(auto-fill,minmax(16rem,1fr))] gap-4 p-4"
      >
        {
          entries.map((entry) =>
            entry.collection === "components" ? (
              <PageCardComponent {entry} />
            ) : (
              <PageCardExample {entry} />
            )
          )
        }
      </div>
    </div>
  </div>
</Layout>
