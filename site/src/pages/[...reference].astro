---
/**
 * @license
 * Copyright 2025-present Ariakit FZ-LLC. All Rights Reserved.
 *
 * This software is proprietary. See the license.md file in the root of this
 * package for licensing terms.
 *
 * SPDX-License-Identifier: UNLICENSED
 */
import {
  ApiReferenceLabel,
  getApiReferencePlainLabel,
} from "#app/components/api-reference-label.react.tsx";
import ApiReferenceProp from "#app/components/api-reference-prop.astro";
import ContainerRightMenu from "#app/components/container-right-menu.astro";
import ContentAdmonition from "#app/components/content-admonition.astro";
import ContentCodeBlock from "#app/components/content-code-block.astro";
import ContentHeading from "#app/components/content-heading.astro";
import ContentLink from "#app/components/content-link.astro";
import ContentParagraph from "#app/components/content-paragraph.astro";
import ContentSeparator from "#app/components/content-separator.astro";
import Markdown from "#app/components/markdown.astro";
import TableOfContents from "#app/components/table-of-contents.astro";
import { getReferenceItemId } from "#app/lib/content.ts";
import type { ReferenceProp } from "#app/lib/schemas.ts";
import type { GetStaticPaths } from "astro";
import { getCollection } from "astro:content";
import { encode } from "html-entities";

export const getStaticPaths = (async () => {
  const references = await getCollection("references");
  return references.map((reference) => {
    const framework = reference.data.framework;
    const componentId = reference.data.componentId;
    const prefix = `${framework}/${componentId}/`;
    const slug = reference.id.replace(prefix, "");
    const path = `${framework}/components/${componentId}/${slug}/partial`;
    return {
      params: { reference: path },
      props: {
        framework,
        reference,
        partialMain: false as boolean | undefined,
      },
    };
  });
}) satisfies GetStaticPaths;

const { reference, partialMain = false } = Astro.props;
const data = reference.data;

type SectionKey =
  | "state"
  | "required-props"
  | "optional-props"
  | "parameters"
  | "return";
type ItemKind = "state" | "prop" | "parameter" | "return-prop";
type TocHeading = { slug: string; depth: number; text: string };
type Section = {
  key: SectionKey;
  title: string;
  id: string;
  itemKind?: ItemKind;
  items?: ReferenceProp[];
  description?: string;
  type?: string;
  typeHtml?: string;
};

// Basic info
const kind = data.kind ?? "component";
const name = data.name;
const tocTitle = getApiReferencePlainLabel(kind, name);

// Deprecation and description
const isDeprecated = Boolean(data.deprecated);
const deprecatedMarkdown =
  typeof data.deprecated === "string" ? data.deprecated : undefined;
const description = data.description;

// Examples pre-formatted as HTML for ContentCodeBlock
const formattedExamples = (data.examples || []).map((example) => ({
  description: example.description,
  codeHtml: `<code class="language-${example.language}"${example.meta ? ` metastring="${encode(example.meta)}"` : ""}>${encode(example.code)}</code>`,
}));

// Sections
const hasPropsParam =
  data.params.length === 1 && data.params[0]?.name === "props";
const STATE_SECTION_DESCRIPTION =
  "State values available on the store. You can subscribe to a specific key or derive values with a selector.";
const sections: Section[] = [];
if (data.state?.length) {
  sections.push({
    key: "state",
    title: "State",
    id: "state",
    itemKind: "state",
    items: data.state,
    description: STATE_SECTION_DESCRIPTION,
  });
}

if (hasPropsParam && data.params[0]?.props?.length) {
  const allProps = data.params[0].props;
  const requiredProps = allProps.filter((p) => !p.optional);
  const optionalProps = allProps.filter((p) => p.optional);
  if (requiredProps.length) {
    sections.push({
      key: "required-props",
      title: "Required Props",
      id: "required-props",
      itemKind: "prop",
      items: requiredProps,
    });
  }
  if (optionalProps.length) {
    sections.push({
      key: "optional-props",
      title: "Optional Props",
      id: "optional-props",
      itemKind: "prop",
      items: optionalProps,
    });
  }
}

if (data.params.length > 0 && !hasPropsParam) {
  sections.push({
    key: "parameters",
    title: "Parameters",
    id: "parameters",
    itemKind: "parameter",
    items: data.params,
  });
}

if (data.returnValue) {
  const rv = data.returnValue;
  sections.push({
    key: "return",
    title: "Return Value",
    id: "return-value",
    itemKind: "return-prop",
    description: rv.description,
    type: rv.type,
    typeHtml: rv.type
      ? `<code class="language-typescript">${rv.type}</code>`
      : undefined,
    items: rv.props,
  });
}

const sectionsToRender: Section[] = partialMain
  ? (() => {
      const firstWithItems = sections.find(
        (s) => (s.items && s.items.length > 0) || s.key === "return"
      );
      if (!firstWithItems) return [] as Section[];
      if (firstWithItems.items && firstWithItems.items.length > 0) {
        return [
          {
            ...firstWithItems,
            items: firstWithItems.items.slice(0, 1),
          },
        ];
      }
      return [firstWithItems];
    })()
  : sections;

const hasSectionsToRender = sectionsToRender.length > 0;

// Generate headings for the Table of Contents from sections
const headings = (() => {
  const entries: TocHeading[] = [];
  for (const section of sections) {
    if (section.key === "return") {
      if (section.items && section.items.length > 0) {
        entries.push({ slug: section.id, depth: 2, text: section.title });
        for (const prop of section.items) {
          entries.push({
            slug: getReferenceItemId("return-prop", prop.name),
            depth: 3,
            text: prop.name,
          });
        }
      }
      continue;
    }
    // Non-return sections (exist only if they have items)
    entries.push({ slug: section.id, depth: 2, text: section.title });
    for (const item of section.items || []) {
      const kindForSlug = section.itemKind ?? "prop";
      entries.push({
        slug: getReferenceItemId(kindForSlug, item.name),
        depth: 3,
        text: item.name,
      });
    }
  }
  return entries;
})();

// Helper code blocks for the state section
const storeStateCodeExamplesHtml = [
  `<code class="language-tsx">const value = Ariakit.useStoreState(store, "key");</code>`,
  `<code class="language-tsx">const derived = Ariakit.useStoreState(store, (state) => state.key);</code>`,
];

export const partial = true;
---

<div class="@container">
  {!partialMain && <div id="api" class="scroll-mt-(--header-height)" />}
  <div class="py-8 @default:pt-16">
    <ContainerRightMenu>
      <Fragment slot="prose">
        <ContentHeading as="h3" class="mt-0 mb-8 ak-heading-2">
          <ApiReferenceLabel symbols kind={kind} set:text={name} />
        </ContentHeading>
      </Fragment>
    </ContainerRightMenu>
    <ContainerRightMenu>
      <Fragment slot="prose">
        {
          isDeprecated && (
            <ContentAdmonition type="warning" title="Deprecated" class="mb-4">
              {deprecatedMarkdown ? (
                <Markdown content={deprecatedMarkdown} />
              ) : (
                ""
              )}
            </ContentAdmonition>
          )
        }
        <Markdown content={description} />
        {
          formattedExamples.map((example) => (
            <Fragment>
              {example.description && (
                <ContentParagraph>{example.description}</ContentParagraph>
              )}
              <ContentCodeBlock set:html={example.codeHtml} />
            </Fragment>
          ))
        }
        {
          hasSectionsToRender && (
            <Fragment>
              {sectionsToRender.map((section) => (
                <Fragment>
                  <ContentHeading
                    as="h4"
                    id={section.id}
                    class="ak-heading-3 mb-0"
                  >
                    <ContentLink href={`#${section.id}`}>
                      {section.title}
                    </ContentLink>
                  </ContentHeading>
                  {section.key === "state" && (
                    <Fragment>
                      <ContentParagraph>{section.description}</ContentParagraph>
                      {storeStateCodeExamplesHtml.map((html) => (
                        <ContentCodeBlock set:html={html} />
                      ))}
                    </Fragment>
                  )}
                  {section.key !== "return" && section.items?.length ? (
                    <Fragment>
                      <ContentSeparator />
                      {section.items.map((item) => (
                        <Fragment>
                          <ApiReferenceProp
                            prefix={section.itemKind}
                            {...item}
                          />
                          <ContentSeparator />
                        </Fragment>
                      ))}
                    </Fragment>
                  ) : null}
                  {section.key === "return" && (
                    <Fragment>
                      {section.items?.length ? (
                        <Fragment>
                          {section.description && (
                            <Markdown content={section.description} />
                          )}
                          {section.items.map((prop) => (
                            <Fragment>
                              <ContentSeparator />
                              <ApiReferenceProp
                                prefix="return-prop"
                                {...prop}
                              />
                            </Fragment>
                          ))}
                        </Fragment>
                      ) : (
                        <Fragment>
                          {section.typeHtml && (
                            <ContentCodeBlock set:html={section.typeHtml} />
                          )}
                          {section.description && (
                            <Markdown content={section.description} />
                          )}
                        </Fragment>
                      )}
                    </Fragment>
                  )}
                </Fragment>
              ))}
            </Fragment>
          )
        }
      </Fragment>
      <TableOfContents
        slot="sidebar"
        headings={headings}
        title={tocTitle}
        titleSlug="api"
        inert={partialMain}
        class="sticky [--top:calc(var(--header-height)+--spacing(2))] top-(--top) max-h-[calc(100dvh-var(--top))] overflow-y-auto"
      />
    </ContainerRightMenu>
  </div>
</div>
